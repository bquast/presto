#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { marked } from 'marked';

const DEFAULT_OUTPUT_DIR = '.';
const CHECK_BRANCHES_ORDER = ['master', 'main', 'gh-pages'];
const DEFAULT_IMAGE_DATA_URL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
const THEME_STORE_BASE_URL = 'https://store.presto.so/themes';
const LOCAL_THEMES_DIR = '.';
const PRIMARY_CANDIDATE_BASES = ['readme', 'index', 'main', 'landing', 'home'];
const MARKDOWN_EXTENSIONS = ['.md', '.markdown'];

function removeMarkdownExtension(filename) {
    for (const ext of MARKDOWN_EXTENSIONS) {
        if (filename.toLowerCase().endsWith(ext)) {
            return filename.slice(0, -ext.length);
        }
    }
    return filename;
}

function buildCandidateFileNames() {
    const variants = new Set();
    const extensionVariants = ['.md', '.MD', '.markdown', '.MARKDOWN'];
    for (const base of PRIMARY_CANDIDATE_BASES) {
        const caseVariants = [
            base,
            base.charAt(0).toUpperCase() + base.slice(1),
            base.toUpperCase()
        ];
        for (const variant of caseVariants) {
            for (const ext of extensionVariants) {
                variants.add(`${variant}${ext}`);
            }
        }
    }
    return Array.from(variants);
}

const initialArgsForVerbose = process.argv.slice(2);
const verboseArgIndexForIsVerbose = initialArgsForVerbose.indexOf('--verbose');
const isVerbose = verboseArgIndexForIsVerbose !== -1;
if (isVerbose) {
    process.env.VERBOSE_PRESTO = 'true';
}

const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{PAGE_TITLE}}</title>
    {{GOOGLE_ANALYTICS_SCRIPT}}
    <meta property="og:type" content="website">
    <meta property="og:url" content="{{OG_URL}}">
    <meta property="og:title" content="{{PAGE_TITLE}}">
    <meta property="og:description" content="View the Markdown site for {{PAGE_TITLE}}.">
    <meta property="og:image" content="{{OG_IMAGE_URL}}">
    <meta property="og:site_name" content="{{PAGE_TITLE}}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="{{OG_URL}}">
    <meta name="twitter:title" content="{{PAGE_TITLE}}">
    <meta name="twitter:description" content="View the Markdown site for {{PAGE_TITLE}}.">
    <meta name="twitter:image" content="{{OG_IMAGE_URL}}">
    <link rel="stylesheet" href="style.css" id="presto-theme-stylesheet">
    <link rel="icon" href="{{FAVICON_URL}}" type="image/png">
</head>
<body>
    <main class="container">
        {{CONTENT}}
        <hr class="presto-footer-separator">
        {{EXTRA_LINKS_HTML}}
        <div class="presto-footer">
            <p>Generated by <a href="https://presto.so" target="_blank" rel="noopener noreferrer">Presto</a>{{FOOTER_REPO_SOURCE_HTML}}</p>
        </div>
    </main>
    {{BROWSER_CONSOLE_LOG_SCRIPT}}
</body>
</html>`;

const CSS_STYLES = `body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #24292e; margin: 0; padding: 0; background-color: #f6f8fa;} .container {max-width: 800px; margin: 30px auto; padding: 20px 40px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);} h1,h2,h3,h4,h5,h6 {margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; border-bottom: 1px solid #eaecef; padding-bottom: .3em;} h1 {font-size: 2em;} h2 {font-size: 1.5em;} h3 {font-size: 1.25em;} h4 {font-size: 1em;} h5 {font-size: .875em;} h6 {font-size: .85em; color: #6a737d;} p {margin-top:0; margin-bottom:16px;} ul,ol {margin-top:0; margin-bottom:16px; padding-left:2em;} a {color:#0366d6; text-decoration:none;} a:hover {text-decoration:underline;} code {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; background-color:rgba(27,31,35,.05); border-radius:3px; padding:.2em .4em; margin:0;} pre {font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size:85%; line-height:1.45; background-color:#f6f8fa; border-radius:3px; padding:16px; overflow:auto; margin-bottom:16px;} pre code {font-size:100%; padding:0; margin:0; background-color:transparent; border:0; display:inline; max-width:auto; overflow:visible; line-height:inherit; word-wrap:normal;} img {max-width:100%; height:auto; box-sizing:border-box; margin-top:16px; margin-bottom:16px;} blockquote {margin:0 0 16px 0; padding:0 1em; color:#6a737d; border-left:.25em solid #dfe2e5;} table {border-collapse:collapse; margin-bottom:16px; width:100%; display:block; overflow:auto;} th,td {border:1px solid #dfe2e5; padding:6px 13px;} tr {background-color:#fff; border-top:1px solid #c6cbd1;} tr:nth-child(2n) {background-color:#f6f8fa;} hr {height:.25em; padding:0; margin:24px 0; background-color:#e1e4e8; border:0;} hr.presto-footer-separator {height: 2px; background-color: #d1d5da; border: none; margin-top: 48px; margin-bottom: 10px;} div.presto-footer {text-align: center; font-size: 0.85em; color: #586069; padding-bottom: 10px; margin-top: 10px;} div.presto-footer p { margin: 0; } div.presto-footer a {color: #0366d6; text-decoration: none;} div.presto-footer a:hover {text-decoration: underline;} .presto-extra-links { text-align: center; margin-top: 10px; margin-bottom: 15px; font-size: 0.9em; color: #586069; } .presto-extra-links p { margin: 0; } .presto-extra-links a { color: #0366d6; text-decoration: none; margin: 0 5px; } .presto-extra-links a:hover { text-decoration: underline; } .presto-extra-links strong { margin: 0 5px; font-weight: bold; }`;

function sanitizeUrlForPublicDisplay(urlString) {
    if (!urlString || typeof urlString !== 'string' || (!urlString.startsWith('http:') && !urlString.startsWith('https://'))) {
        return urlString;
    }
    try {
        const urlObj = new URL(urlString);
        return `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? ':' + urlObj.port : ''}${urlObj.pathname}${urlObj.search}${urlObj.hash}`;
    } catch (e) {
        if (isVerbose) console.warn(`Warning: Could not sanitize URL '${urlString}': ${e.message}`);
        return urlString;
    }
}

function getPlainTextFromInlineTokens(inlineTokens) {
    return inlineTokens
        .map(token => {
            if (token.type === 'text' || token.type === 'codespan') {
                return token.raw || token.text;
            }
            if (token.tokens && token.tokens.length > 0) {
                return getPlainTextFromInlineTokens(token.tokens);
            }
            return token.raw || token.text || '';
        })
        .join('');
}

function extractFirstH1(markdownContent) {
    if (!markdownContent) return null;
    try {
        const tokens = marked.lexer(markdownContent);
        const firstH1Token = tokens.find(token => token.type === 'heading' && token.depth === 1);
        if (firstH1Token && firstH1Token.tokens) {
            let title = getPlainTextFromInlineTokens(firstH1Token.tokens).trim();
            title = title
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"')
                .replace(/&#39;/g, "'")
                .replace(/&#039;/g, "'");
            return title || null;
        }
    } catch (e) {
        if (isVerbose) console.warn(`Warning: Could not extract H1 title: ${e.message}`);
    }
    return null;
}

function isLikelyRepoIdentifier(arg) {
    return arg.includes('/') || arg.startsWith('http:') || arg.startsWith('https://');
}

function isUrl(str) {
    return str.startsWith('http:') || str.startsWith('https://') || str.startsWith('file://');
}

async function parseRepoIdentifier(identifier) {
    if (!identifier) {
        throw new Error('Repository identifier argument is missing.');
    }
    try {
        const url = new URL(identifier);
        const hostname = url.hostname.toLowerCase();
        const pathParts = url.pathname.split('/').filter(Boolean);
        if (pathParts.length < 2) {
            throw new Error(`URL path does not seem to contain enough segments: ${url.pathname}`);
        }
        if (hostname === 'github.com') {
            return {
                type: 'github',
                host: hostname,
                user: pathParts[0],
                repoName: pathParts[1].replace(/\.git$/, ''),
                originalIdentifier: identifier
            };
        } else if (hostname === 'gitlab.com') {
            const repoName = pathParts[pathParts.length - 1].replace(/\.git$/, '');
            const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/');
            return {
                type: 'gitlab',
                host: hostname,
                userOrGroupPath,
                repoName,
                originalIdentifier: identifier
            };
        } else if (url.protocol === 'https:') {
            const repoName = pathParts[pathParts.length - 1].replace(/\.git$/, '');
            const userOrGroupPath = pathParts.slice(0, pathParts.length - 1).join('/');
            if (isVerbose) console.log(`Info: Processing unknown host '${hostname}' like GitLab.`);
            return {
                type: 'unknown_gitlab_like',
                host: hostname,
                userOrGroupPath,
                repoName,
                originalIdentifier: identifier
            };
        }
    } catch (e) {
        if (!(e instanceof TypeError && e.message.includes('Invalid URL'))) {
            if (isVerbose) console.warn(`URL parse failed for '${identifier}': ${e.message}. Trying 'user/repo'.`);
        }
    }
    if (identifier.includes('://')) {
        throw new Error(`Invalid repo identifier: '${identifier}'.`);
    }
    const parts = identifier.split('/');
    if (parts.length === 2 && parts[0] && parts[1] && !parts[0].includes('.') && !parts[1].includes('.')) {
        return {
            type: 'user_slash_repo',
            user: parts[0],
            repoName: parts[1],
            originalIdentifier: identifier
        };
    }
    throw new Error(`Could not parse repo identifier: '${identifier}'. Use 'user/repo' or a full URL.`);
}

async function tryFetchForProvider(providerRepoInfo, branches, filePath) {
    let lastBranchError = null;
    for (const branch of branches) {
        let fileUrl;
        if (providerRepoInfo.type === 'github') {
            fileUrl = `https://raw.githubusercontent.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}/${branch}/${filePath}`;
        } else if (providerRepoInfo.type === 'gitlab' || providerRepoInfo.type === 'unknown_gitlab_like') {
            fileUrl = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}/-/raw/${branch}/${filePath}`;
        } else {
            return { content: null, branch: null, error: new Error(`Internal error: Unsupported provider: ${providerRepoInfo.type}`) };
        }
        if (isVerbose) console.log(`Attempting: ${fileUrl}`);
        try {
            const response = await fetch(fileUrl);
            if (response.ok) {
                return { content: await response.text(), branch, error: null };
            }
            if (response.status === 404) {
                lastBranchError = new Error(`${filePath} not found on branch '${branch}'`);
                if (isVerbose) console.warn(lastBranchError.message);
            } else {
                throw new Error(`Failed to fetch ${filePath}. Status: ${response.status} ${response.statusText}`);
            }
        } catch (fetchError) {
            lastBranchError = new Error(`Network error for ${fileUrl}: ${fetchError.message}`);
            console.warn(lastBranchError.message);
            return { content: null, branch: null, error: lastBranchError };
        }
    }
    return {
        content: null,
        branch: null,
        error: lastBranchError || new Error(`${filePath} not found on any branch for ${providerRepoInfo.repoName}.`)
    };
}

async function listMarkdownFilesGitHub(user, repoName, branch) {
    const apiUrl = `https://api.github.com/repos/${user}/${repoName}/contents/?ref=${branch}`;
    if (isVerbose) console.log(`Listing files from: ${apiUrl}`);
    try {
        const response = await fetch(apiUrl, {
            headers: { 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!response.ok) {
            return { success: false, error: new Error(`GitHub API status ${response.status}`) };
        }
        const filesList = await response.json();
        const mdFileNames = filesList
            .filter(file => {
                if (file.type !== 'file') return false;
                const lower = file.name.toLowerCase();
                return MARKDOWN_EXTENSIONS.some(ext => lower.endsWith(ext));
            })
            .map(file => file.name);
        return { success: true, files: mdFileNames };
    } catch (apiError) {
        return { success: false, error: apiError };
    }
}

function selectPrimaryMarkdownFile(mdFiles) {
    if (!mdFiles || mdFiles.length === 0) return null;
    if (mdFiles.length === 1) return mdFiles[0];
    const getBase = file => {
        const lower = file.toLowerCase();
        for (const ext of MARKDOWN_EXTENSIONS) {
            if (lower.endsWith(ext)) {
                return lower.slice(0, -ext.length);
            }
        }
        return lower;
    };
    for (const candidate of PRIMARY_CANDIDATE_BASES) {
        const found = mdFiles.find(file => getBase(file) === candidate);
        if (found) return found;
    }
    return mdFiles.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))[0];
}

async function fetchRemoteMarkdown(initialRepoInfo) {
    const candidateNames = buildCandidateFileNames();

    const tryProvider = async providerRepoInfo => {
        for (const branch of CHECK_BRANCHES_ORDER) {
            let candidateFiles = null;
            if (providerRepoInfo.type === 'github') {
                const listResult = await listMarkdownFilesGitHub(providerRepoInfo.user, providerRepoInfo.repoName, branch);
                if (listResult.success && listResult.files.length > 0) {
                    candidateFiles = listResult.files;
                } else if (listResult.success && listResult.files.length === 0) {
                    continue;
                } else if (listResult.error && isVerbose) {
                    console.warn(`GitHub API listing failed: ${listResult.error.message}. Falling back to direct fetch.`);
                }
            }

            let primaryFile = null;
            if (candidateFiles) {
                primaryFile = selectPrimaryMarkdownFile(candidateFiles);
            }

            const filesToTry = [];
            if (primaryFile) filesToTry.push(primaryFile);
            for (const candidate of candidateNames) {
                if (!filesToTry.find(f => f.toLowerCase() === candidate.toLowerCase())) {
                    filesToTry.push(candidate);
                }
            }

            for (const fileName of filesToTry) {
                const result = await tryFetchForProvider(providerRepoInfo, [branch], fileName);
                if (result.content) {
                    const mdFilesContent = { [fileName]: result.content };
                    let otherFiles = {};
                    if (providerRepoInfo.type === 'github') {
                        let list = candidateFiles;
                        if (!list) {
                            const listResult = await listMarkdownFilesGitHub(providerRepoInfo.user, providerRepoInfo.repoName, branch);
                            list = listResult.success ? listResult.files : [];
                        }
                        const otherMd = list.filter(name => name.toLowerCase() !== fileName.toLowerCase());
                        otherFiles = await fetchOtherMdFilesGitHub(providerRepoInfo.user, providerRepoInfo.repoName, branch, otherMd);
                    }
                    return {
                        mdFilesContent: { ...mdFilesContent, ...otherFiles },
                        branch,
                        primaryFileName: fileName,
                        providerRepoInfo
                    };
                }
            }
        }
        return null;
    };

    if (initialRepoInfo.type === 'user_slash_repo') {
        if (isVerbose) console.log(`Input '${initialRepoInfo.originalIdentifier}' is shorthand, trying GitHub...`);
        const githubInfo = {
            type: 'github',
            host: 'github.com',
            user: initialRepoInfo.user,
            repoName: initialRepoInfo.repoName,
            originalIdentifier: initialRepoInfo.originalIdentifier
        };
        const githubResult = await tryProvider(githubInfo);
        if (githubResult) {
            return githubResult;
        }
        console.warn(`GitHub failed for '${initialRepoInfo.originalIdentifier}'. Trying GitLab...`);
        const gitlabInfo = {
            type: 'gitlab',
            host: 'gitlab.com',
            userOrGroupPath: initialRepoInfo.user,
            repoName: initialRepoInfo.repoName,
            originalIdentifier: initialRepoInfo.originalIdentifier
        };
        const gitlabResult = await tryProvider(gitlabInfo);
        if (gitlabResult) {
            return gitlabResult;
        }
        throw new Error(`Could not resolve '${initialRepoInfo.originalIdentifier}' on GitHub or GitLab.com.`);
    }

    const providerResult = await tryProvider(initialRepoInfo);
    if (!providerResult) {
        throw new Error(`Could not find a Markdown file for '${initialRepoInfo.originalIdentifier}'.`);
    }
    return providerResult;
}

async function fetchOtherMdFilesGitHub(user, repoName, branch, mdFileNames = []) {
    const otherFiles = {};
    const namesToFetch = mdFileNames.length > 0 ? mdFileNames : [];
    if (namesToFetch.length === 0) {
        const listResult = await listMarkdownFilesGitHub(user, repoName, branch);
        if (!listResult.success) {
            if (isVerbose) console.warn(`GitHub API list failed (Status: ${listResult.error?.message || 'unknown'}).`);
            return otherFiles;
        }
        listResult.files.forEach(name => {
            if (!namesToFetch.includes(name)) namesToFetch.push(name);
        });
    }

    for (const fileName of namesToFetch) {
        const lower = fileName.toLowerCase();
        if (!MARKDOWN_EXTENSIONS.some(ext => lower.endsWith(ext))) continue;
        const rawUrl = `https://raw.githubusercontent.com/${user}/${repoName}/${branch}/${fileName}`;
        if (isVerbose) console.log(`Fetching: ${rawUrl}`);
        try {
            const fileResponse = await fetch(rawUrl);
            if (fileResponse.ok) {
                otherFiles[fileName] = await fileResponse.text();
            } else {
                console.warn(`Warning: Failed to fetch ${fileName} (Status: ${fileResponse.status})`);
            }
        } catch (fetchError) {
            console.warn(`Warning: Fetch error for ${fileName}: ${fetchError.message}`);
        }
    }
    return otherFiles;
}

async function getLocalGitRepoInfo() {
    try {
        const gitConfigPath = path.join(process.cwd(), '.git', 'config');
        const configContent = await fs.readFile(gitConfigPath, 'utf-8');
        const originUrlMatch = configContent.match(/\[remote\s+"origin"\]\s*[^\[]*?\s*url\s*=\s*([^\s]+)/);
        if (originUrlMatch && originUrlMatch[1]) {
            let url = originUrlMatch[1];
            url = url.replace(/^git@([^:]+):(.+?)(\.git)?$/, 'https://$1/$2');
            if (url.endsWith('.git')) url = url.substring(0, url.length - 4);
            if (url.startsWith('http://')) url = 'https://' + url.substring(7);
            if (!url.startsWith('https://')) {
                if (isVerbose) console.log(`Non-standard remote URL: ${originUrlMatch[1]}`);
                return null;
            }
            let displayName = url;
            try {
                const parsedUrl = new URL(url);
                const pathParts = parsedUrl.pathname.split('/').filter(Boolean);
                displayName = pathParts.length >= 2 ? `${pathParts[pathParts.length - 2]}/${pathParts[pathParts.length - 1]}` : pathParts[0] || url;
            } catch (e) {
                // ignore
            }
            return { url, name: displayName };
        }
    } catch (e) {
        if (isVerbose) console.log(`No local git info. (${e.message})`);
    }
    return null;
}

async function fetchOrReadContent(pathOrUrl, isThemeAsset = false) {
    if (!pathOrUrl) return null;
    const isHttpUrl = pathOrUrl.startsWith('http:') || pathOrUrl.startsWith('https://');
    if (isVerbose) console.log(`Getting content from ${isHttpUrl ? 'URL' : 'path'}: ${pathOrUrl}`);
    try {
        if (isHttpUrl) {
            const response = await fetch(pathOrUrl);
            if (!response.ok) {
                if (isThemeAsset && response.status === 404) return null;
                throw new Error(`Fetch failed ${pathOrUrl}. Status: ${response.status}`);
            }
            return await response.text();
        }
        return await fs.readFile(pathOrUrl, 'utf-8');
    } catch (e) {
        if (isThemeAsset) {
            if (isVerbose) console.warn(`Theme asset not found/read '${pathOrUrl}': ${e.message}`);
            return null;
        }
        throw new Error(`Could not read/fetch '${pathOrUrl}': ${e.message}`);
    }
}

async function generateSinglePage(markdownContent, pageTitle, outputDir, outputFilename, ogUrlToUse, ogImageUrl, gaPropertyId, customHtmlTemplate, cssFileToLink, footerLinkHref, footerLinkText, allMdFiles = [], currentFileBase = '') {
    if (isVerbose) console.log(`Generating page "${pageTitle}" -> ${path.join(outputDir, outputFilename)}`);
    const htmlContent = marked.parse(markdownContent);
    const faviconUrl = DEFAULT_IMAGE_DATA_URL;
    let gaScriptHtml = '';
    if (gaPropertyId) {
        gaScriptHtml = `<script async src="https://www.googletagmanager.com/gtag/js?id=${gaPropertyId}"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','${gaPropertyId}');</script>`;
    }
    let displayPathForConsole = 'N/A';
    let repoUrl = footerLinkHref || ogUrlToUse || '';
    if (repoUrl) {
        try {
            const u = new URL(repoUrl);
            let p = u.pathname.endsWith('.git') ? u.pathname.slice(0, -4) : u.pathname;
            p = p.startsWith('/') ? p.substring(1) : p;
            displayPathForConsole = `${u.hostname}/${p}`;
        } catch (e) {
            displayPathForConsole = repoUrl;
        }
    } else if (footerLinkText) {
        displayPathForConsole = footerLinkText;
    }
    const safeConsolePath = displayPathForConsole.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${}');
    const browserConsoleLogScript = `<script> console.log(\`Page generated by Presto (https://presto.so/) from ${safeConsolePath}\`); </script>`;
    let footerRepoHtml = '';
    if (footerLinkHref && footerLinkText) {
        footerRepoHtml = ` from <a href="${footerLinkHref}" target="_blank" rel="noopener noreferrer">${footerLinkText}</a>`;
    } else if (footerLinkText) {
        footerRepoHtml = ` from ${footerLinkText}`;
    }
    let extraLinksHtml = '';
    if (allMdFiles.length > 1) {
        extraLinksHtml = '<div class="presto-extra-links"><p>';
        const links = allMdFiles.map(file => {
            const base = removeMarkdownExtension(path.basename(file));
            const htmlFile = base.toLowerCase() === 'readme' ? 'index.html' : base + '.html';
            const linkText = base;
            if (base.toLowerCase() === currentFileBase.toLowerCase()) {
                return `<strong>${linkText}</strong>`;
            }
            return `<a href="${htmlFile}">${linkText}</a>`;
        });
        extraLinksHtml += links.join(' | ');
        extraLinksHtml += '</p></div>';
    }
    let finalHtmlTemplate = customHtmlTemplate || HTML_TEMPLATE;
    finalHtmlTemplate = finalHtmlTemplate.replace(/<link rel="stylesheet" href=".*?" id="presto-theme-stylesheet">/, `<link rel="stylesheet" href="${cssFileToLink}" id="presto-theme-stylesheet">`);
    const finalHtml = finalHtmlTemplate
        .replace(/{{PAGE_TITLE}}/g, pageTitle)
        .replace('{{GOOGLE_ANALYTICS_SCRIPT}}', gaScriptHtml)
        .replace(/{{OG_URL}}/g, ogUrlToUse || '')
        .replace(/{{FAVICON_URL}}/g, faviconUrl)
        .replace(/{{OG_IMAGE_URL}}/g, ogImageUrl || faviconUrl)
        .replace('{{FOOTER_REPO_SOURCE_HTML}}', footerRepoHtml)
        .replace('{{BROWSER_CONSOLE_LOG_SCRIPT}}', browserConsoleLogScript)
        .replace('{{EXTRA_LINKS_HTML}}', extraLinksHtml)
        .replace('{{CONTENT}}', htmlContent);
    try {
        await fs.writeFile(path.join(outputDir, outputFilename), finalHtml);
    } catch (error) {
        throw new Error(`Failed to write ${outputFilename}: ${error.message}`);
    }
}

async function main() {
    let rawArgs = process.argv.slice(2);
    if (rawArgs.includes('--verbose')) {
        if (!process.env.VERBOSE_PRESTO) process.env.VERBOSE_PRESTO = 'true';
        rawArgs = rawArgs.filter(arg => arg !== '--verbose');
        if (isVerbose) console.log('Verbose mode enabled.');
    }

    let repoIdentifierArg = null,
        outputDirArg = DEFAULT_OUTPUT_DIR,
        imageUrlArg = null,
        gaPropertyIdArg = null,
        themeArg = null,
        paletteArg = null;
    let localMode = false;
    const remainingArgs = [];
    for (let i = 0; i < rawArgs.length; i++) {
        const arg = rawArgs[i];
        if (arg === '--image') {
            imageUrlArg = i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--') ? rawArgs[++i] : (console.warn('Warning: --image needs URL.'), null);
        } else if (arg === '--ga') {
            gaPropertyIdArg = i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--') ? rawArgs[++i] : (console.warn('Warning: --ga needs ID.'), null);
        } else if (arg === '--theme') {
            themeArg = i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--') ? rawArgs[++i] : (console.warn('Warning: --theme needs name/URL.'), null);
        } else if (arg === '--palette') {
            paletteArg = i + 1 < rawArgs.length && !rawArgs[i + 1].startsWith('--') ? rawArgs[++i] : (console.warn('Warning: --palette needs name.'), null);
        } else {
            remainingArgs.push(arg);
        }
    }
    rawArgs = remainingArgs;

    if (rawArgs.length === 0) {
        localMode = true;
    } else if (rawArgs.length === 1) {
        if (isLikelyRepoIdentifier(rawArgs[0])) {
            repoIdentifierArg = rawArgs[0];
        } else {
            localMode = true;
            outputDirArg = rawArgs[0];
        }
    } else {
        repoIdentifierArg = rawArgs[0];
        outputDirArg = rawArgs[1];
    }

    if (!localMode && !repoIdentifierArg && !themeArg) {
        console.error('Error: Could not determine operation. Provide repo or use local mode.');
        process.exit(1);
    }

    try {
        const resolvedOutputDir = path.resolve(outputDirArg);
        await fs.mkdir(resolvedOutputDir, { recursive: true });
        let ogUrlToUse = '';
        let footerLinkHref = null;
        let footerLinkText = null;
        let customCssContent = null;
        let customHtmlTemplate = null;
        let resolvedThemeCssFilename = 'style.css';

        if (themeArg) {
            let themeName = themeArg;
            if (paletteArg) themeName = `${themeArg}-${paletteArg}`;
            resolvedThemeCssFilename = `${themeName}.css`;
            let cssUrl;
            let htmlUrl;
            if (isUrl(themeArg)) {
                cssUrl = themeArg.endsWith('.css') ? themeArg : new URL(`${themeName}.css`, themeArg.endsWith('/') ? themeArg : themeArg + '/').toString();
                htmlUrl = cssUrl.replace(/\.css$/, '.html');
                resolvedThemeCssFilename = path.basename(cssUrl);
            } else {
                cssUrl = `${THEME_STORE_BASE_URL}/${resolvedThemeCssFilename}`;
                htmlUrl = `${THEME_STORE_BASE_URL}/${themeName}.html`;
            }
            customCssContent = await fetchOrReadContent(cssUrl, true);
            customHtmlTemplate = await fetchOrReadContent(htmlUrl, true);
            if (!customCssContent) {
                cssUrl = path.join(LOCAL_THEMES_DIR, resolvedThemeCssFilename);
                htmlUrl = path.join(LOCAL_THEMES_DIR, `${themeName}.html`);
                customCssContent = await fetchOrReadContent(cssUrl, true);
                if (!customHtmlTemplate) customHtmlTemplate = await fetchOrReadContent(htmlUrl, true);
            }
            if (!customCssContent) throw new Error(`Theme CSS for '${themeName}' not found.`);
            if (isVerbose) console.log(`Using theme: ${themeName}`);
        }

        const finalOgImageUrl = imageUrlArg || DEFAULT_IMAGE_DATA_URL;
        const cssFileToWrite = resolvedThemeCssFilename || 'style.css';
        await fs.writeFile(path.join(resolvedOutputDir, cssFileToWrite), customCssContent || CSS_STYLES);
        if (isVerbose) console.log(`Wrote ${cssFileToWrite}`);

        let allMdContent = {};
        let allMdFiles = [];
        let primaryFileName = 'README.md';

        if (localMode) {
            console.log(`Processing local files -> '${resolvedOutputDir}'`);
            const dirents = await fs.readdir(process.cwd(), { withFileTypes: true });
            const localFiles = dirents
                .filter(d => {
                    if (!d.isFile()) return false;
                    const lower = d.name.toLowerCase();
                    return MARKDOWN_EXTENSIONS.some(ext => lower.endsWith(ext));
                })
                .map(d => d.name);
            if (localFiles.length === 0) throw new Error('Local mode error: No Markdown files found.');
            primaryFileName = selectPrimaryMarkdownFile(localFiles);
            if (!primaryFileName) throw new Error('Local mode error: Could not select a Markdown file.');
            for (const f of localFiles) {
                allMdContent[f] = await fs.readFile(f, 'utf-8');
            }
            const gitInfo = await getLocalGitRepoInfo();
            if (gitInfo) {
                ogUrlToUse = sanitizeUrlForPublicDisplay(gitInfo.url);
                footerLinkHref = ogUrlToUse;
                footerLinkText = gitInfo.name;
            }
        } else {
            const initialRepoInfo = await parseRepoIdentifier(repoIdentifierArg);
            ogUrlToUse = initialRepoInfo.originalIdentifier.startsWith('http')
                ? sanitizeUrlForPublicDisplay(initialRepoInfo.originalIdentifier)
                : '';
            console.log(`Processing remote '${initialRepoInfo.originalIdentifier}' -> '${resolvedOutputDir}'`);
            const { mdFilesContent, branch, primaryFileName: remotePrimary, providerRepoInfo } = await fetchRemoteMarkdown(initialRepoInfo);
            primaryFileName = remotePrimary;
            allMdContent = mdFilesContent;
            allMdFiles = Object.keys(allMdContent);
            if (providerRepoInfo.type === 'github') {
                footerLinkHref = `https://github.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}`;
                footerLinkText = `github.com/${providerRepoInfo.user}/${providerRepoInfo.repoName}`;
            } else {
                footerLinkHref = `https://${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`;
                footerLinkText = `${providerRepoInfo.host}/${providerRepoInfo.userOrGroupPath}/${providerRepoInfo.repoName}`;
            }
            ogUrlToUse = ogUrlToUse || footerLinkHref;
            if (isVerbose) console.log(`Markdown fetched from ${providerRepoInfo.host || providerRepoInfo.type} (branch: ${branch || 'unknown'})`);
        }

        if (Object.keys(allMdContent).length === 0) {
            throw new Error('No Markdown content found.');
        }

        if (allMdFiles.length === 0) {
            allMdFiles = Object.keys(allMdContent);
        }

        const primaryLower = primaryFileName.toLowerCase();
        allMdFiles.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();
            if (aLower === primaryLower) return -1;
            if (bLower === primaryLower) return 1;
            const aBase = removeMarkdownExtension(a).toLowerCase();
            const bBase = removeMarkdownExtension(b).toLowerCase();
            if (aBase === 'readme') return -1;
            if (bBase === 'readme') return 1;
            return a.localeCompare(b, undefined, { sensitivity: 'base' });
        });

        let defaultPageTitle = 'Presto';
        if (localMode) {
            try {
                const pkg = JSON.parse(await fs.readFile('package.json', 'utf-8'));
                defaultPageTitle = pkg.name || defaultPageTitle;
            } catch (e) {
                defaultPageTitle = path.basename(process.cwd());
            }
        } else if (repoIdentifierArg) {
            try {
                const p = new URL(ogUrlToUse || 'http://example.com/').pathname.split('/').filter(Boolean);
                defaultPageTitle = p[1] || p[0] || defaultPageTitle;
            } catch (e) {
                // ignore
            }
        }

        for (const mdFile of allMdFiles) {
            const content = allMdContent[mdFile];
            if (!content) continue;
            const baseName = removeMarkdownExtension(path.basename(mdFile));
            const title = extractFirstH1(content) || baseName || defaultPageTitle;
            const isPrimary = mdFile.toLowerCase() === primaryFileName.toLowerCase();
            const outputName = baseName.toLowerCase() === 'readme' || isPrimary ? 'index.html' : `${baseName}.html`;
            await generateSinglePage(
                content,
                title,
                resolvedOutputDir,
                outputName,
                ogUrlToUse,
                finalOgImageUrl,
                gaPropertyIdArg,
                customHtmlTemplate,
                cssFileToWrite,
                footerLinkHref,
                footerLinkText,
                allMdFiles,
                baseName
            );
        }

        console.log(`\n✅ Site generation complete! Files in: ${resolvedOutputDir}`);
        if (!process.env.CI) {
            console.log(
                "\nDeployment Hints:\n  - For GitHub Pages, push the output directory to a 'gh-pages' branch.\n  - For Cloudflare Pages or Netlify, configure them to deploy the output directory.\n  - You can also serve it locally: 'npx serve " + path.basename(resolvedOutputDir) + "'"
            );
        }
    } catch (error) {
        console.error(`\n❌ Error: ${error.message}`);
        if (isVerbose && error.stack) console.error(error.stack);
        process.exit(1);
    }
}

main();
